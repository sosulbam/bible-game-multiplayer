<!-- ======================================================================= -->
<!-- =======================   index.html (진행자 화면)   ======================= -->
<!-- ======================================================================= -->
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>말씀의 빛: 그룹 대전 (진행자 화면)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator/qrcode.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Gowun+Dodum&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Gowun Dodum', sans-serif; background-color: #f0f9ff; }
        .game-canvas { background: linear-gradient(to bottom, #38bdf8, #e0f2fe); border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        .category-btn.selected, .mode-btn.selected, .gameplay-btn.selected, .assign-btn.selected, .theme-btn.selected { background-color: #0ea5e9; color: white; }
        .player-item { cursor: pointer; transition: background-color 0.2s; }
        .player-item:hover { background-color: #dbeafe; }
        
        /* 두더지 게임 스타일 */
        #mole-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; width: 100%; max-width: 600px; margin: 0 auto; aspect-ratio: 1 / 1; }
        .mole-hole { background-color: #a16f5a; border-radius: 50%; border-bottom: 10px solid #78523f; position: relative; overflow: hidden; }
        .mole-hole::before { content: ''; position: absolute; top: 20%; left: 50%; transform: translateX(-50%); width: 80%; height: 40%; background: #5c3d2e; border-radius: 50%; }
        .mole { position: absolute; bottom: -100%; left: 50%; transform: translateX(-50%); width: 70%; transition: bottom 0.2s ease-out; cursor: pointer; }
        .mole.up { bottom: 10%; }
        .mole img { width: 100%; display: block; }
        .mole .word-plate { position: absolute; bottom: 90%; left: 50%; transform: translateX(-50%); background: #fff; border: 3px solid #663300; border-radius: 8px; padding: 2px 8px; font-size: 1.2rem; font-weight: bold; white-space: nowrap; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        .hit-effect { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 4rem; opacity: 0; animation: fade-out 0.5s; pointer-events: none; }
        @keyframes fade-out { from { opacity: 1; transform: translate(-50%, -50%) scale(1); } to { opacity: 0; transform: translate(-50%, -70%) scale(1.2); } }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen">

    <div id="game-container" class="w-full max-w-5xl mx-auto p-4 text-center">
        <!-- 대기 화면 -->
        <div id="lobby-screen">
            <h1 class="text-4xl font-bold text-sky-700 mb-4">말씀의 빛: 그룹 대전</h1>
            <p class="text-xl text-gray-600 mb-6">스마트폰으로 QR 코드를 스캔하여 게임에 참여하세요!</p>
            
            <div class="max-w-4xl mx-auto bg-white/70 p-4 rounded-lg shadow-md mb-6">
                <h3 class="text-xl font-bold text-gray-700 mb-3">게임 설정</h3>
                
                <div class="mb-4">
                    <label class="font-bold">게임 방식:</label>
                    <div id="gameplay-mode-selector" class="inline-flex rounded-md shadow-sm" role="group">
                      <button type="button" data-gameplay="fill-in-blank" class="gameplay-btn selected py-2 px-4 text-sm font-medium text-gray-900 bg-white rounded-l-lg border border-gray-200 hover:bg-gray-100">말씀 채우기</button>
                      <button type="button" data-gameplay="mole-whack" class="gameplay-btn py-2 px-4 text-sm font-medium text-gray-900 bg-white rounded-r-md border border-gray-200 hover:bg-gray-100">두더지 잡기</button>
                    </div>
                </div>

                <div class="mb-4 flex justify-center items-center gap-6">
                    <div>
                        <label class="font-bold">게임 모드:</label>
                        <div id="game-mode-selector" class="inline-flex rounded-md shadow-sm" role="group">
                          <button type="button" data-mode="personal" class="mode-btn selected py-2 px-4 text-sm font-medium text-gray-900 bg-white rounded-l-lg border border-gray-200 hover:bg-gray-100">개인전</button>
                          <button type="button" data-mode="team" class="mode-btn py-2 px-4 text-sm font-medium text-gray-900 bg-white rounded-r-md border border-gray-200 hover:bg-gray-100">팀전</button>
                        </div>
                    </div>
                    <div id="team-settings-container" class="hidden flex items-center gap-6">
                        <div>
                            <label class="font-bold">팀 이름 테마:</label>
                            <div id="team-theme-selector" class="inline-flex rounded-md shadow-sm" role="group">
                                <button type="button" data-theme="animals" class="theme-btn selected py-2 px-4 text-sm font-medium text-gray-900 bg-white rounded-l-lg border border-gray-200 hover:bg-gray-100">동물</button>
                                <button type="button" data-theme="bible" class="theme-btn py-2 px-4 text-sm font-medium text-gray-900 bg-white rounded-r-md border border-gray-200 hover:bg-gray-100">성경 인물</button>
                            </div>
                        </div>
                        <div>
                            <label class="font-bold">팀 배정 방식:</label>
                            <div id="team-assign-selector" class="inline-flex rounded-md shadow-sm" role="group">
                                <button type="button" data-assign="auto" class="assign-btn selected py-2 px-4 text-sm font-medium text-gray-900 bg-white rounded-l-lg border border-gray-200 hover:bg-gray-100">자동 배정</button>
                                <button type="button" data-assign="choice" class="assign-btn py-2 px-4 text-sm font-medium text-gray-900 bg-white rounded-r-md border border-gray-200 hover:bg-gray-100">참가자 선택</button>
                            </div>
                        </div>
                        <button id="reshuffle-btn" class="py-2 px-4 text-sm font-medium text-white bg-green-500 rounded-lg hover:bg-green-600">팀 재분배</button>
                    </div>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-left">
                    <div>
                        <label class="font-bold">카테고리 선택 (다중 선택 가능):</label>
                        <div id="category-selector" class="mt-2 flex flex-wrap gap-2 p-2 bg-gray-100 rounded-md max-h-64 overflow-y-auto"></div>
                    </div>
                    <div class="space-y-3">
                        <div id="fill-in-blank-settings">
                            <div>
                                <label for="rounds-input" class="font-bold">문제 수:</label>
                                <input type="number" id="rounds-input" value="10" min="5" max="50" step="1" class="w-full p-2 border rounded-md">
                            </div>
                            <div>
                                <label for="time-limit-input" class="font-bold">총 게임 시간 (분):</label>
                                <input type="number" id="time-limit-input" value="1" min="1" max="10" step="1" class="w-full p-2 border rounded-md">
                            </div>
                        </div>
                        <div id="mole-whack-settings" class="hidden">
                             <div>
                                <label for="mole-rounds-input" class="font-bold">문제 수:</label>
                                <input type="number" id="mole-rounds-input" value="10" min="5" max="50" step="1" class="w-full p-2 border rounded-md">
                            </div>
                            <div>
                                <label for="mole-speed-input" class="font-bold">두더지 출현 시간 (초):</label>
                                <input type="number" id="mole-speed-input" value="5.0" min="0.5" max="10" step="0.1" class="w-full p-2 border rounded-md">
                            </div>
                             <div>
                                <label for="mole-time-limit-input" class="font-bold">라운드 제한 시간 (초):</label>
                                <input type="number" id="mole-time-limit-input" value="20" min="5" max="30" step="1" class="w-full p-2 border rounded-md">
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="flex flex-col md:flex-row items-center justify-center gap-8">
                <div id="qrcode" class="p-4 bg-white rounded-lg shadow-md"></div>
                <div id="player-list-container" class="w-full max-w-md">
                    <h2 class="text-2xl font-bold mb-3">참가자 목록 (<span id="player-count">0</span>명)</h2>
                    <ul id="player-list" class="text-left text-lg space-y-1 h-48 overflow-y-auto p-2 bg-gray-100 rounded-lg">
                        <li class="text-gray-500 p-2">아직 참가자가 없습니다...</li>
                    </ul>
                </div>
                <div id="team-display" class="hidden w-full max-w-md grid-cols-2 gap-4">
                    <div>
                        <h2 id="team-a-name" class="text-2xl font-bold mb-3 text-blue-600"></h2>
                        <ul id="team-a-list" class="text-left text-lg space-y-1 h-48 overflow-y-auto p-2 bg-blue-50 rounded-lg"></ul>
                    </div>
                    <div>
                        <h2 id="team-b-name" class="text-2xl font-bold mb-3 text-red-600"></h2>
                        <ul id="team-b-list" class="text-left text-lg space-y-1 h-48 overflow-y-auto p-2 bg-red-50 rounded-lg"></ul>
                    </div>
                </div>
            </div>
            <div class="mt-8">
                <button id="start-game-button" class="bg-sky-500 hover:bg-sky-600 text-white font-bold py-3 px-8 rounded-full text-2xl transition shadow-lg disabled:bg-gray-400 disabled:cursor-not-allowed" disabled>게임 시작</button>
            </div>
            <div class="mt-4 space-y-2">
                 <p class="text-gray-500">게임 ID: <span id="game-id-display"></span></p>
                 <div id="pc-join-url-container" class="mt-2 hidden">
                    <p class="text-gray-600">PC 참가자용 주소:</p>
                    <div class="flex items-center justify-center gap-2 mt-1">
                        <input type="text" id="pc-join-url" class="w-full max-w-md p-2 border rounded-md bg-gray-100 text-center" readonly>
                        <button id="copy-url-button" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-md transition">복사</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- 게임 화면 -->
        <div id="game-screen" class="hidden">
            <div id="game-ui" class="mb-4 p-3 bg-white/80 backdrop-blur-sm rounded-xl shadow-lg flex justify-between items-center gap-6">
                <div class="flex-none flex items-center divide-x divide-gray-300">
                    <div class="px-4 text-center">
                        <div class="text-sm text-gray-600">문제</div>
                        <div id="round-counter" class="font-bold text-2xl text-sky-700">1 / 10</div>
                    </div>
                    <div class="px-4 text-center">
                        <div class="text-sm text-gray-600">남은 시간</div>
                        <div id="timer" class="font-bold text-2xl text-red-500">01:00</div>
                    </div>
                </div>
                <div id="question-box" class="flex-grow text-center">
                    <p id="question-verse" class="text-4xl font-bold text-sky-800 mb-1"></p>
                    <p id="question-text" class="text-xl text-gray-700"></p>
                </div>
                <div class="flex-none flex items-center gap-2">
                    <button id="sound-toggle-btn" class="p-2 rounded-full hover:bg-gray-200 transition">
                        <svg id="sound-on-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
                        </svg>
                        <svg id="sound-off-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" clip-rule="evenodd" />
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 14l-2-2m0 0l-2-2m2 2l2 2m-2-2l2-2" />
                        </svg>
                    </button>
                    <button id="pause-game-btn" class="py-2 px-4 text-sm font-medium text-white bg-yellow-500 rounded-lg hover:bg-yellow-600">일시정지</button>
                    <button id="force-end-game-btn" class="py-2 px-4 text-sm font-medium text-white bg-red-500 rounded-lg hover:bg-red-600">즉시 종료</button>
                </div>
            </div>
            
            <canvas id="fill-in-blank-canvas" class="game-canvas"></canvas>
            <div id="mole-whack-canvas" class="hidden">
                 <div id="mole-grid"></div>
            </div>

            <div id="scoreboard" class="mt-2 flex flex-wrap justify-center gap-4"></div>
        </div>
        
        <!-- 결과 화면 -->
        <div id="result-screen" class="hidden">
            <h1 id="result-title" class="text-5xl font-bold text-amber-500 mb-8">🎉 최종 결과 🎉</h1>
            <div id="final-ranking" class="space-y-4 max-w-md mx-auto">
            </div>
            <button id="restart-button" class="mt-12 bg-sky-500 hover:bg-sky-600 text-white font-bold py-3 px-8 rounded-full text-2xl transition shadow-lg">새 게임 시작</button>
        </div>

    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getFirestore, doc, collection, onSnapshot, updateDoc, addDoc, query, serverTimestamp, runTransaction, writeBatch } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";

        // --- Firebase Initialization ---
        const firebaseConfig = {
            apiKey: "AIzaSyBCNjgy_28rzMu66Si9W4U6y6sZ6kffIPk",
            authDomain: "verse-game.firebaseapp.com",
            projectId: "verse-game",
            storageBucket: "verse-game.appspot.com",
            messagingSenderId: "84261757024",
            appId: "1:84261757024:web:9f59c6bf44ab0ebb982305"
        };
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // --- DOM Elements ---
        const lobbyScreen = document.getElementById('lobby-screen');
        const gameScreen = document.getElementById('game-screen');
        const resultScreen = document.getElementById('result-screen');
        const qrcodeContainer = document.getElementById('qrcode');
        const playerCountEl = document.getElementById('player-count');
        const startGameButton = document.getElementById('start-game-button');
        const gameIdDisplay = document.getElementById('game-id-display');
        const pcJoinUrlContainer = document.getElementById('pc-join-url-container');
        const pcJoinUrlInput = document.getElementById('pc-join-url');
        const copyUrlButton = document.getElementById('copy-url-button');
        const scoreboard = document.getElementById('scoreboard');
        const questionVerseEl = document.getElementById('question-verse');
        const questionTextEl = document.getElementById('question-text');
        const roundCounterEl = document.getElementById('round-counter');
        const timerEl = document.getElementById('timer');
        const finalRanking = document.getElementById('final-ranking');
        const resultTitle = document.getElementById('result-title');
        const restartButton = document.getElementById('restart-button');
        const categorySelector = document.getElementById('category-selector');
        
        const playerListContainer = document.getElementById('player-list-container');
        const playerList = document.getElementById('player-list');
        const teamDisplay = document.getElementById('team-display');
        const teamANameEl = document.getElementById('team-a-name');
        const teamBNameEl = document.getElementById('team-b-name');
        const teamAListEl = document.getElementById('team-a-list');
        const teamBListEl = document.getElementById('team-b-list');
        
        const gameplayModeSelector = document.getElementById('gameplay-mode-selector');
        const fillInBlankSettings = document.getElementById('fill-in-blank-settings');
        const moleWhackSettings = document.getElementById('mole-whack-settings');
        const roundsInput = document.getElementById('rounds-input');
        const timeLimitInput = document.getElementById('time-limit-input');
        const moleRoundsInput = document.getElementById('mole-rounds-input');
        const moleSpeedInput = document.getElementById('mole-speed-input');
        const moleTimeLimitInput = document.getElementById('mole-time-limit-input');
        
        const gameModeSelector = document.getElementById('game-mode-selector');
        const teamSettingsContainer = document.getElementById('team-settings-container');
        const teamThemeSelector = document.getElementById('team-theme-selector');
        const teamAssignSelector = document.getElementById('team-assign-selector');
        
        const reshuffleBtn = document.getElementById('reshuffle-btn');
        const pauseGameBtn = document.getElementById('pause-game-btn');
        const forceEndGameBtn = document.getElementById('force-end-game-btn');
        const soundToggleBtn = document.getElementById('sound-toggle-btn');
        const soundOnIcon = document.getElementById('sound-on-icon');
        const soundOffIcon = document.getElementById('sound-off-icon');

        const fillInBlankCanvas = document.getElementById('fill-in-blank-canvas');
        const ctx = fillInBlankCanvas.getContext('2d');
        const moleWhackCanvas = document.getElementById('mole-whack-canvas');
        const moleGrid = document.getElementById('mole-grid');

        // --- State Variables ---
        let gameId;
        let gameplayMode = 'fill-in-blank';
        let players = {};
        let teams = {};
        let gameMode = 'personal';
        let assignMode = 'auto';
        let teamTheme = 'animals';
        let playersUnsubscribe, actionsUnsubscribe;
        let versesData = [];
        let currentBlankWord;
        let enemies = [];
        let particles = [];
        let beams = [];
        let gameTimerId = null;
        let roundTimerId = null;
        let roundActive = false;
        let isGamePaused = false;
        let synth;
        let isSoundEnabled = true;
        let selectedCategories = [];
        let totalRounds = 10;
        let totalGameTime = 60;
        let moles = [];
        let moleGameInterval = null;
        let currentMoleSpeed = 5.0;

        // --- Constants ---
        const difficultySettings = {
            speed: 0.5, 
            points: 10,
            penalty: -5
        };

        const teamNameThemes = {
            animals: ["🦁 사자", "🐯 호랑이", "🐻 곰", "🦊 여우", "🦅 독수리", "🦄 유니콘", "🐉 용", "🐘 코끼리", "🐬 돌고래", "🦈 상어"],
            bible: ["🔑 베드로", "📜 야고보", "🕊️ 요한", "⚔️ 바울", "🌴 드보라", "🙏 한나", "⚕️ 모세", "⭐ 아브라함", "💖 마리아", "👑 다윗", "🐑 라헬", "🏺 리브가", "🌾 룻"]
        };
        
        // --- Classes for Fill-in-Blank Game ---
        class PlayerCharacter {
            constructor(id, name, teamId) {
                this.id = id;
                this.name = name;
                this.teamId = teamId;
                this.width = 50;
                this.height = 40;
                this.x = Math.random() * (fillInBlankCanvas.width - this.width);
                this.y = fillInBlankCanvas.height - this.height - 10;
                this.flash = 0;
                
                const sheepSVG = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="-2 -2 64 49">
                      <g fill="white" stroke="${this.teamId === 'teamA' ? '#3b82f6' : '#ef4444'}" stroke-width="3">
                        <path d="M20,25 a10,10 0 1,1 20,0 a15,15 0 1,1 -20,0" transform="translate(0, 5)"/>
                        <circle cx="15" cy="20" r="8"/><circle cx="45" cy="20" r="8"/><circle cx="30" cy="12" r="10"/>
                        <g fill="#000" stroke="none"><circle cx="25" cy="30" r="1.5"/><circle cx="35" cy="30" r="1.5"/></g>
                        <path d="M 28 35 q 2 -3 4 0" stroke="black" fill="none" stroke-width="1"/>
                      </g>
                      <rect x="20" y="38" width="5" height="7" rx="2" fill="white" stroke="${this.teamId === 'teamA' ? '#3b82f6' : '#ef4444'}" stroke-width="3" /><rect x="35" y="38" width="5" height="7" rx="2" fill="white" stroke="${this.teamId === 'teamA' ? '#3b82f6' : '#ef4444'}" stroke-width="3"/>
                    </svg>`;
                this.image = new Image();
                this.image.src = `data:image/svg+xml;base64,${btoa(sheepSVG)}`;
            }
            draw() {
                if (this.flash > 0) {
                    ctx.globalAlpha = 0.5 + (Math.sin(Date.now() / 50) * 0.5);
                    this.flash--;
                }
                ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                ctx.globalAlpha = 1.0;
                ctx.fillStyle = this.teamId === 'teamA' ? '#3b82f6' : '#ef4444';
                ctx.textAlign = 'center';
                ctx.font = 'bold 14px Gowun Dodum';
                ctx.fillText(this.name, this.x + this.width / 2, this.y - 5);
            }
            shoot() {
                this.flash = 30;
                const beamColor = this.teamId === 'teamA' ? '59, 130, 246' : '239, 68, 68';
                beams.push(new Beam(this.x + this.width / 2, this.y, beamColor));
            }
        }
        
        class Enemy {
             constructor(x, y, word, isCorrect, number) {
                this.x = x; this.y = y;
                this.speed = (Math.random() * 0.5 + 0.8) * difficultySettings.speed;
                this.word = word; this.isCorrect = isCorrect;
                this.number = number;
                ctx.font = 'bold 30px Gowun Dodum';
                this.width = ctx.measureText(this.word).width + 40;
                this.height = 50;

                const monsterSVG = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="${this.width}" height="${this.height}">
                        <path d="M5,45 C5,20 45,20 45,45 Q40,40 35,45 C30,40 20,40 15,45 Q10,40 5,45 Z" fill="#4A5568"/>
                        <circle cx="18" cy="25" r="4" fill="white">
                            <animate attributeName="cy" values="25;22;25" dur="1s" repeatCount="indefinite" />
                        </circle>
                        <circle cx="32" cy="25" r="4" fill="white">
                            <animate attributeName="cy" values="25;22;25" dur="1s" repeatCount="indefinite" />
                        </circle>
                    </svg>`;
                this.image = new Image();
                this.image.src = `data:image/svg+xml;base64,${btoa(monsterSVG)}`;
            }
            draw() {
                ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                ctx.font = 'bold 30px Gowun Dodum';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 6;
                ctx.strokeText(this.word, this.x + this.width / 2, this.y + this.height / 2 + 2);
                ctx.fillStyle = '#FFFFFF';
                ctx.fillText(this.word, this.x + this.width / 2, this.y + this.height / 2 + 2);
                
                ctx.font = 'bold 22px Arial';
                ctx.fillStyle = 'yellow';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.strokeText(this.number, this.x + this.width / 2, this.y - 10);
                ctx.fillText(this.number, this.x + this.width / 2, this.y - 10);
            }
            update() { 
                if (!isGamePaused) this.y += this.speed;
                this.draw();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y;
                this.radius = Math.random() * 4 + 2;
                this.speedX = Math.random() * 6 - 3;
                this.speedY = Math.random() * 6 - 3;
                this.life = 100;
                this.color = color;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${this.color}, ${this.life / 100})`;
                ctx.fill();
            }
            update() {
                if (isGamePaused) return;
                this.x += this.speedX; this.y += this.speedY;
                this.life -= 3;
                this.draw();
            }
        }

        class Beam {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.width = 15;
                this.life = 15; 
            }
            draw() {
                const alpha = this.life / 15;
                ctx.fillStyle = `rgba(${this.color}, ${alpha * 0.8})`;
                ctx.shadowColor = `rgb(${this.color})`;
                ctx.shadowBlur = 20;
                ctx.fillRect(this.x - this.width / 2, 0, this.width, this.y);
                ctx.shadowBlur = 0;
            }
            update() {
                if (!isGamePaused) this.life--;
            }
        }
        
        // --- Audio Functions ---
        function setupAudio() {
            if (synth || (Tone.context && Tone.context.state === 'running')) return;
            try {
                Tone.start();
                synth = new Tone.PolySynth(Tone.Synth).toDestination();
            } catch (e) {
                console.warn("Could not start audio context.", e);
            }
        }
        
        const playSound = (logic) => {
            if (synth && isSoundEnabled) logic();
        };

        const playCorrectSound = () => playSound(() => synth.triggerAttackRelease(['C5', 'G5'], '8n'));
        const playIncorrectSound = () => playSound(() => synth.triggerAttackRelease('C3', '8n'));
        const playRoundStartSound = () => playSound(() => synth.triggerAttackRelease('C4', '8n'));
        const playFinishSound = () => playSound(() => synth.triggerAttackRelease(['C4', 'E4', 'G4', 'C5'], '4n'));
        const playWhackSound = () => playSound(() => synth.triggerAttackRelease('E3', '16n'));
        
        function toggleSound() {
            isSoundEnabled = !isSoundEnabled;
            soundOnIcon.classList.toggle('hidden', !isSoundEnabled);
            soundOffIcon.classList.toggle('hidden', isSoundEnabled);
        }

        // --- Core Game Logic ---
        async function initializeHost() {
            const nameTheme = teamNameThemes[teamTheme];
            const teamAIndex = Math.floor(Math.random() * nameTheme.length);
            let teamBIndex;
            do {
                teamBIndex = Math.floor(Math.random() * nameTheme.length);
            } while (teamAIndex === teamBIndex);
            
            teams = {
                teamA: { name: nameTheme[teamAIndex], score: 0 },
                teamB: { name: nameTheme[teamBIndex], score: 0 }
            };

            const gameDocRef = await addDoc(collection(db, "games"), {
                state: "lobby",
                createdAt: serverTimestamp(),
                mode: gameMode,
                assignMode: assignMode,
                teams: teams,
                settings: { gameplayMode: gameplayMode }
            });
            gameId = gameDocRef.id;
            gameIdDisplay.textContent = gameId;
            const joinUrl = `${window.location.origin}/join.html?gameId=${gameId}`;
            pcJoinUrlInput.value = joinUrl;
            pcJoinUrlContainer.classList.remove('hidden');
            const qr = qrcode(0, 'L');
            qr.addData(joinUrl);
            qr.make();
            qrcodeContainer.innerHTML = qr.createImgTag(6);
            
            const playersQuery = query(collection(db, "games", gameId, "players"));
            
            playersUnsubscribe = onSnapshot(playersQuery, (snapshot) => {
                const currentPlayersInDB = {};
                 snapshot.forEach(doc => {
                    currentPlayersInDB[doc.id] = doc.data();
                });

                snapshot.docChanges().forEach(change => {
                    if (change.type === "added") {
                        const newPlayerId = change.doc.id;
                        const newPlayerData = change.doc.data();
                        if (gameMode === 'team' && assignMode === 'auto' && !newPlayerData.team) {
                            const teamAPlayers = Object.values(players).filter(p => p.team === 'teamA').length;
                            const teamBPlayers = Object.values(players).filter(p => p.team === 'teamB').length;
                            const teamToAssign = teamAPlayers <= teamBPlayers ? 'teamA' : 'teamB';
                            updateDoc(doc(db, "games", gameId, "players", newPlayerId), { team: teamToAssign });
                        }
                    }
                });
                
                players = {};
                 for (const id in currentPlayersInDB) {
                    players[id] = { ...currentPlayersInDB[id], character: null };
                }

                updatePlayerListUI();
                if (gameMode === 'personal') {
                    updateScoreboard(players);
                }
                
                startGameButton.disabled = Object.keys(players).length === 0;
            });

            onSnapshot(doc(db, "games", gameId), (docSnap) => {
                if (docSnap.exists() && docSnap.data().teams) {
                    const gameData = docSnap.data();
                    teams = gameData.teams;
                    gameMode = gameData.mode;
                     if (gameMode === 'team') {
                        teamANameEl.textContent = teams.teamA.name;
                        teamBNameEl.textContent = teams.teamB.name;
                        updateTeamScoreboard();
                    }
                }
            });
        }

        function updatePlayerListUI() {
            playerList.innerHTML = '';
            teamAListEl.innerHTML = '';
            teamBListEl.innerHTML = '';
            const playerIds = Object.keys(players);
            playerCountEl.textContent = playerIds.length;
            
            if (playerIds.length === 0) {
                playerList.innerHTML = '<li class="text-gray-500 p-2">아직 참가자가 없습니다...</li>';
                return;
            }

            playerIds.forEach(id => {
                const playerData = players[id];
                const li = document.createElement('li');
                li.className = 'player-item p-2 rounded-md';
                li.textContent = `🐑 ${playerData.name}`;
                li.dataset.playerId = id;

                if (gameMode === 'team') {
                    if (playerData.team === 'teamA') teamAListEl.appendChild(li);
                    else if (playerData.team === 'teamB') teamBListEl.appendChild(li);
                    else playerList.appendChild(li); 
                } else {
                    playerList.appendChild(li);
                }
            });
        }

        function updateScoreboard(playerData) {
            scoreboard.innerHTML = '';
            const sortedPlayers = Object.entries(playerData).sort((a, b) => b[1].score - a[1].score);
            for (const [id, data] of sortedPlayers) {
                const div = document.createElement('div');
                div.className = 'p-2 bg-white/80 rounded-md shadow text-center';
                div.innerHTML = `<div class="font-bold text-lg">${data.name}</div><div class="text-xl">${data.score}점</div>`;
                scoreboard.appendChild(div);
            }
        }

        function updateTeamScoreboard() {
            scoreboard.innerHTML = '';
            Object.entries(teams).forEach(([teamId, teamData]) => {
                const color = teamId === 'teamA' ? 'blue' : 'red';
                const div = document.createElement('div');
                div.className = `p-4 bg-${color}-100 border-2 border-${color}-500 rounded-lg shadow-lg text-center`;
                div.innerHTML = `<div class="font-bold text-2xl text-${color}-700">${teamData.name}</div><div class="text-3xl">${teamData.score}점</div>`;
                scoreboard.appendChild(div);
            });
        }
        
        function listenForActions() {
            const actionsRef = collection(db, "games", gameId, "actions");
            actionsUnsubscribe = onSnapshot(actionsRef, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    if (change.type === "added" && change.doc.data().timestamp) {
                        const action = change.doc.data();
                        if (gameplayMode === 'fill-in-blank') {
                            handlePlayerAction(action.playerId, action.payload);
                        } else if (gameplayMode === 'mole-whack') {
                            handleMoleWhackAction(action.playerId, action.payload);
                        }
                    }
                });
            });
        }

        async function handlePlayerAction(playerId, payload) {
            if (!roundActive || isGamePaused) return;
            const targetNumber = parseInt(payload.target, 10);
            const targetEnemy = enemies.find(e => e.number === targetNumber);
            if (targetEnemy) {
                const player = players[playerId];
                if (player && player.character) {
                    player.character.x = targetEnemy.x + (targetEnemy.width / 2) - (player.character.width / 2);
                    player.character.shoot();
                }

                try {
                    await runTransaction(db, async (transaction) => {
                        const playerDocRef = doc(db, "games", gameId, "players", playerId);
                        const gameDocRef = doc(db, "games", gameId);
                        const playerDoc = await transaction.get(playerDocRef);
                        const gameDoc = await transaction.get(gameDocRef);

                        if (!playerDoc.exists() || !gameDoc.exists() || !roundActive) return;
                        
                        const currentScore = playerDoc.data().score || 0;
                        const currentTeam = playerDoc.data().team;
                        const currentTeams = gameDoc.data().teams;

                        if (targetEnemy.isCorrect) {
                            roundActive = false;
                            playCorrectSound();
                            
                            transaction.update(playerDocRef, { score: currentScore + difficultySettings.points });
                            if (gameMode === 'team' && currentTeam) {
                                const newTeamScore = (currentTeams[currentTeam].score || 0) + difficultySettings.points;
                                transaction.update(gameDocRef, { [`teams.${currentTeam}.score`]: newTeamScore });
                            }

                            for(let i = 0; i < 30; i++) {
                                particles.push(new Particle(targetEnemy.x + targetEnemy.width/2, targetEnemy.y + targetEnemy.height/2, '255, 215, 0'));
                            }
                            enemies = [];
                            setTimeout(() => nextRound(), 2000);
                        } else {
                            playIncorrectSound();
                            if (gameMode === 'team' && currentTeam) {
                                const newTeamScore = (currentTeams[currentTeam].score || 0) + difficultySettings.penalty;
                                transaction.update(gameDocRef, { [`teams.${currentTeam}.score`]: newTeamScore });
                            }
                        }
                    });
                } catch (e) {
                    console.error("Transaction failed: ", e);
                }
            }
        }
        
        async function handleMoleWhackAction(playerId, payload) {
            if (!roundActive || isGamePaused) return;
            
            const holeIndex = payload.holeIndex;
            const mole = moles[holeIndex];
            
            if (!mole || !mole.isUp) return;

            playWhackSound();
            
            const holeElement = document.getElementById(`mole-hole-${holeIndex}`);
            const effect = document.createElement('div');
            effect.className = 'hit-effect';
            
            if (mole.isCorrect) {
                effect.textContent = '⭐';
            } else {
                effect.textContent = '💨';
            }
            holeElement.appendChild(effect);
            setTimeout(() => effect.remove(), 500);

            mole.hide();

            try {
                await runTransaction(db, async (transaction) => {
                    const playerDocRef = doc(db, "games", gameId, "players", playerId);
                    const gameDocRef = doc(db, "games", gameId);
                    const playerDoc = await transaction.get(playerDocRef);
                    const gameDoc = await transaction.get(gameDocRef);

                    if (!playerDoc.exists() || !gameDoc.exists() || !roundActive) return;

                    const currentScore = playerDoc.data().score || 0;
                    const currentTeam = playerDoc.data().team;
                    const currentTeams = gameDoc.data().teams;

                    if (mole.isCorrect) {
                        roundActive = false;
                        playCorrectSound();
                        
                        transaction.update(playerDocRef, { score: currentScore + difficultySettings.points });
                        if (gameMode === 'team' && currentTeam) {
                            const newTeamScore = (currentTeams[currentTeam].score || 0) + difficultySettings.points;
                            transaction.update(gameDocRef, { [`teams.${currentTeam}.score`]: newTeamScore });
                        }
                        
                        clearInterval(moleGameInterval);
                        clearInterval(roundTimerId);
                        setTimeout(() => nextRound(), 2000);

                    } else {
                        playIncorrectSound();
                        transaction.update(playerDocRef, { score: currentScore + difficultySettings.penalty });
                        if (gameMode === 'team' && currentTeam) {
                            const newTeamScore = (currentTeams[currentTeam].score || 0) + difficultySettings.penalty;
                            transaction.update(gameDocRef, { [`teams.${currentTeam}.score`]: newTeamScore });
                        }
                    }
                });
            } catch (e) {
                console.error("Mole Whack Transaction failed: ", e);
            }
        }

        async function startGame() {
            selectedCategories = [...categorySelector.querySelectorAll('.selected')].map(btn => btn.dataset.category);
            if (selectedCategories.length === 0) {
                alert('하나 이상의 카테고리를 선택해주세요.');
                return;
            }

            setupAudio();
            listenForActions();
            lobbyScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            
            let settings;
            if (gameplayMode === 'fill-in-blank') {
                totalRounds = parseInt(roundsInput.value) || 10;
                totalGameTime = (parseInt(timeLimitInput.value) || 1) * 60;
                fillInBlankCanvas.classList.remove('hidden');
                moleWhackCanvas.classList.add('hidden');
                fillInBlankCanvas.width = document.getElementById('game-container').clientWidth;
                fillInBlankCanvas.height = Math.min(window.innerHeight * 0.7, 700);
                Object.keys(players).forEach(id => {
                    players[id].character = new PlayerCharacter(id, players[id].name, players[id].team);
                });
                startTotalGameTimer();
                animate();
                settings = { categories: selectedCategories, rounds: totalRounds, time: totalGameTime, gameplayMode };
            } else {
                totalRounds = parseInt(moleRoundsInput.value) || 10;
                currentMoleSpeed = parseFloat(moleSpeedInput.value) || 5.0;
                fillInBlankCanvas.classList.add('hidden');
                moleWhackCanvas.classList.remove('hidden');
                createMoleGrid();
                settings = { categories: selectedCategories, rounds: totalRounds, moleSpeed: currentMoleSpeed, moleTimeLimit: parseInt(moleTimeLimitInput.value), gameplayMode };
            }

            await updateDoc(doc(db, "games", gameId), { 
                state: "playing",
                settings: settings
            });
            
            nextRound();
        }
        
        let currentRound = 0;
        async function nextRound() {
            if (currentRound >= totalRounds) {
                endGame();
                return;
            }
            currentRound++;
            roundCounterEl.textContent = `${currentRound} / ${totalRounds}`;
            
            if (gameplayMode === 'fill-in-blank') {
                await nextRoundFillInBlank();
            } else {
                await nextRoundMoleWhack();
            }
        }

        async function nextRoundFillInBlank() {
            roundActive = true;
            playRoundStartSound();
            enemies = [];
            particles = [];
            beams = [];
            
            let filteredVerses = versesData;
            if (!selectedCategories.includes('전체')) {
                filteredVerses = versesData.filter(v => v.카테고리 && selectedCategories.includes(v.카테고리));
            }
            if (filteredVerses.length === 0) {
                alert('선택한 카테고리에 해당하는 말씀 구절이 없습니다. 게임을 종료합니다.');
                endGame();
                return;
            }
            
            let verse, words, blankIndex, candidateWords;
            let attempts = 0;
            do {
                verse = filteredVerses[Math.floor(Math.random() * filteredVerses.length)];
                words = verse.본문.split(' ').filter(w => w.trim().length > 0);
                candidateWords = words.filter(isValidBlankWord);
                attempts++;
            } while (candidateWords.length === 0 && attempts < 50);

            if (candidateWords.length === 0) {
                candidateWords = words.filter(w => w.length > 1);
                if(candidateWords.length === 0) { nextRound(); return; }
            }

            currentBlankWord = candidateWords[Math.floor(Math.random() * candidateWords.length)];
            blankIndex = words.indexOf(currentBlankWord);
            
            const distractors = generateDistractors(currentBlankWord, versesData);

            const options = [currentBlankWord, ...distractors];
            options.sort(() => Math.random() - 0.5);
            options.forEach((word, i) => {
                const x = (fillInBlankCanvas.width / (options.length + 1)) * (i + 1) - 50;
                enemies.push(new Enemy(x, -60, word, word === currentBlankWord, i + 1));
            });
            const questionPayload = {
                verse: `[${verse.장절}]`,
                text: words.map((w, i) => (i === blankIndex ? '_______' : w)).join(' '),
            };
            questionVerseEl.textContent = questionPayload.verse;
            questionTextEl.textContent = questionPayload.text;
            await updateDoc(doc(db, "games", gameId), {
                currentRound,
                question: questionPayload,
            });
        }
        
        async function nextRoundMoleWhack() {
            roundActive = true;
            playRoundStartSound();
            
            const baseSpeed = parseFloat(moleSpeedInput.value) || 5.0;
            currentMoleSpeed = Math.max(0.5, baseSpeed - (currentRound * 0.1));

            let filteredVerses = versesData;
            if (!selectedCategories.includes('전체')) {
                filteredVerses = versesData.filter(v => v.카테고리 && selectedCategories.includes(v.카테고리));
            }
            if (filteredVerses.length === 0) {
                alert('선택한 카테고리에 해당하는 말씀 구절이 없습니다. 게임을 종료합니다.');
                endGame();
                return;
            }
            
            const verse = filteredVerses[Math.floor(Math.random() * filteredVerses.length)];
            const firstWord = verse.본문.split(' ')[0].replace(/[.,!?]/g, '');

            const allFirstWords = Array.from(new Set(versesData.map(v => v.본문.split(' ')[0].replace(/[.,!?]/g, ''))));
            const distractors = [];
            while(distractors.length < 8) {
                const randomWord = allFirstWords[Math.floor(Math.random() * allFirstWords.length)];
                if (randomWord && randomWord !== firstWord && !distractors.includes(randomWord)) {
                    distractors.push(randomWord);
                }
            }

            moles.forEach(mole => mole.reset());
            const wordsForRound = [firstWord, ...distractors];
            wordsForRound.sort(() => Math.random() - 0.5);

            moles.forEach((mole, index) => {
                mole.word = wordsForRound[index];
                mole.isCorrect = (mole.word === firstWord);
            });

            const questionPayload = {
                verse: `[${verse.장절}]`,
                text: '첫 어절을 잡으세요!',
            };
            questionVerseEl.textContent = questionPayload.verse;
            questionTextEl.textContent = questionPayload.text;
            
            await updateDoc(doc(db, "games", gameId), {
                currentRound,
                question: questionPayload,
            });

            startMoleGameLoop();
            startRoundTimer();
        }

        function startRoundTimer() {
            clearInterval(roundTimerId);
            let timeLeft = parseInt(moleTimeLimitInput.value);
            timerEl.textContent = String(timeLeft).padStart(2, '0');
            roundTimerId = setInterval(() => {
                if (isGamePaused) return;
                timeLeft--;
                timerEl.textContent = String(timeLeft).padStart(2, '0');
                if (timeLeft <= 0) {
                    clearInterval(roundTimerId);
                    clearInterval(moleGameInterval);
                    if (roundActive) {
                        roundActive = false;
                        setTimeout(() => nextRound(), 2000);
                    }
                }
            }, 1000);
        }

        function startMoleGameLoop() {
            clearInterval(moleGameInterval);
            moleGameInterval = setInterval(() => {
                if (!roundActive || isGamePaused) return;

                const availableMoles = moles.filter(m => !m.isUp);
                if (availableMoles.length === 0) return;
                
                let molesToPop = 1;
                if (currentRound > 7) {
                    molesToPop = 3;
                } else if (currentRound > 3) {
                    molesToPop = 2;
                }
                
                const finalMolesToPop = Math.min(molesToPop, availableMoles.length);

                for (let i = 0; i < finalMolesToPop; i++) {
                    const moleIndex = Math.floor(Math.random() * availableMoles.length);
                    const mole = availableMoles.splice(moleIndex, 1)[0];
                    if (mole) {
                        mole.pop();
                    }
                }
            }, 1000);
        }

        function createMoleGrid() {
            moleGrid.innerHTML = '';
            moles = [];
            for (let i = 0; i < 9; i++) {
                const hole = document.createElement('div');
                hole.id = `mole-hole-${i}`;
                hole.className = 'mole-hole';
                
                const moleEl = document.createElement('div');
                moleEl.className = 'mole';
                moleEl.innerHTML = `<div class="word-plate"></div><img src="https://i.imgur.com/4M5hY3g.png" alt="두더지">`;
                hole.appendChild(moleEl);
                moleGrid.appendChild(hole);

                moles.push({
                    element: moleEl,
                    word: '',
                    isCorrect: false,
                    isUp: false,
                    timeoutId: null,
                    pop() {
                        if (this.isUp) return;
                        this.isUp = true;
                        this.element.querySelector('.word-plate').textContent = this.word;
                        this.element.classList.add('up');
                        this.timeoutId = setTimeout(() => this.hide(), currentMoleSpeed * 1000);
                    },
                    hide() {
                        this.isUp = false;
                        this.element.classList.remove('up');
                    },
                    reset() {
                        this.hide();
                        clearTimeout(this.timeoutId);
                        this.word = '';
                        this.isCorrect = false;
                    }
                });
            }
        }
        
        function startTotalGameTimer() {
            let timeLeft = totalGameTime;
            timerEl.textContent = `${String(Math.floor(timeLeft/60)).padStart(2, '0')}:${String(timeLeft%60).padStart(2, '0')}`;
            gameTimerId = setInterval(() => {
                if(isGamePaused) return;
                timeLeft--;
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                timerEl.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                if (timeLeft <= 0) {
                    endGame();
                }
            }, 1000);
        }

        function animate() {
            if (gameplayMode !== 'fill-in-blank' || gameScreen.classList.contains('hidden')) return;
            requestAnimationFrame(animate);
            if (isGamePaused) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, fillInBlankCanvas.width, fillInBlankCanvas.height);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 48px Gowun Dodum';
                ctx.textAlign = 'center';
                ctx.fillText('일시정지됨', fillInBlankCanvas.width / 2, fillInBlankCanvas.height / 2);
                return;
            }

            ctx.clearRect(0, 0, fillInBlankCanvas.width, fillInBlankCanvas.height);
            for (const id in players) {
                if(players[id].character) players[id].character.draw();
            }
            enemies.forEach((e, i) => {
                if (e.y > fillInBlankCanvas.height) {
                    enemies.splice(i, 1);
                } else {
                    e.update();
                }
            });
            if (roundActive && enemies.length === 0) {
                roundActive = false;
                setTimeout(() => nextRound(), 1500);
            }
            
            beams.forEach(b => b.draw());
            beams.forEach((b, i) => {
                b.update();
                if (b.life <= 0) beams.splice(i, 1);
            });
            
            particles.forEach((p, i) => {
                p.update();
                if (p.life <= 0) particles.splice(i, 1);
            });
        }

        async function endGame() {
            if (gameScreen.classList.contains('hidden')) return;
            roundActive = false;
            clearInterval(gameTimerId);
            clearInterval(roundTimerId);
            clearInterval(moleGameInterval);
            playFinishSound();
            if (actionsUnsubscribe) actionsUnsubscribe();
            gameScreen.classList.add('hidden');
            resultScreen.classList.remove('hidden');
            await updateDoc(doc(db, "games", gameId), { state: "finished" });

            if (gameMode === 'team') {
                 const winnerTeamId = teams.teamA.score > teams.teamB.score ? 'teamA' : (teams.teamB.score > teams.teamA.score ? 'teamB' : null);
                
                if (winnerTeamId) {
                    const winnerTeam = teams[winnerTeamId];
                    const loserTeam = teams[winnerTeamId === 'teamA' ? 'teamB' : 'teamA'];
                    
                    const winningPlayers = Object.values(players).filter(p => p.team === winnerTeamId);
                    const mvp = winningPlayers.length > 0 ? winningPlayers.sort((a, b) => b.score - a.score)[0] : null;

                    resultTitle.textContent = `🎉 ${winnerTeam.name} 팀 승리! 🎉`;
                    finalRanking.innerHTML = `
                        <div class="p-6 bg-green-100 border-2 border-green-500 rounded-lg shadow-lg">
                            <h3 class="text-3xl font-bold text-green-700">${winnerTeam.name}</h3>
                            <p class="text-4xl">${winnerTeam.score}점</p>
                            ${mvp ? `<p class="mt-2 text-lg">👑 최고 기여자: ${mvp.name} (${mvp.score}점)</p>` : ''}
                        </div>
                        <div class="p-4 bg-gray-100 rounded-lg">
                            <h3 class="text-2xl font-bold text-gray-700">${loserTeam.name}</h3>
                            <p class="text-3xl">${loserTeam.score}점</p>
                        </div>
                    `;
                } else {
                     resultTitle.textContent = `무승부!`;
                     finalRanking.innerHTML = `
                        <div class="grid grid-cols-2 gap-4">
                            <div class="p-6 bg-blue-100 border-2 border-blue-500 rounded-lg shadow-lg">
                                <h3 class="text-3xl font-bold text-blue-700">${teams.teamA.name}</h3>
                                <p class="text-4xl">${teams.teamA.score}점</p>
                            </div>
                            <div class="p-6 bg-red-100 border-2 border-red-500 rounded-lg shadow-lg">
                                <h3 class="text-3xl font-bold text-red-700">${teams.teamB.name}</h3>
                                <p class="text-4xl">${teams.teamB.score}점</p>
                            </div>
                        </div>
                     `;
                }
            } else {
                resultTitle.textContent = '🎉 최종 결과 🎉';
                const sortedPlayers = Object.values(players).sort((a,b) => b.score - a.score);
                finalRanking.innerHTML = '';
                sortedPlayers.forEach((p, index) => {
                    const div = document.createElement('div');
                    const rankEmoji = ['🥇', '🥈', '🥉'][index] || `${index + 1}위`;
                    div.className = 'p-4 bg-white rounded-lg shadow-md flex justify-between items-center text-2xl';
                    div.innerHTML = `<span class="font-bold">${rankEmoji} ${p.name}</span><span>${p.score}점</span>`;
                    finalRanking.appendChild(div);
                });
            }
        }

        function isValidBlankWord(word) {
            const particlesAndEndings = ['은', '는', '이', '가', '을', '를', '의', '에', '에게', '께', '에서', '으로', '로', '와', '과', '도', '만', '뿐', '까지', '마저', '조차', '부터', '하고', '이며', '이라', '다', '요', '죠', '고', '며', '니', '네', '라', '나', '까', '습니다', 'ㅂ니다', '어요', '아요'];
            const cleanWord = word.replace(/[.,!?]/g, '');
            if (cleanWord.length <= 1) return false;
            for (const p of particlesAndEndings) {
                if (cleanWord.endsWith(p)) return false;
            }
            return true;
        }

        function generateDistractors(correctWord, allVerses) {
            const candidatePool = Array.from(new Set(
                allVerses
                    .flatMap(v => v.본문.split(' '))
                    .map(w => w.replace(/[.,!?]/g, ''))
                    .filter(w => w.length > 1 && w !== correctWord)
            ));

            for (let i = candidatePool.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [candidatePool[i], candidatePool[j]] = [candidatePool[j], candidatePool[i]];
            }
            
            const distractors = new Set(candidatePool.slice(0, 2));

            const genericDistractors = ["사랑", "믿음", "소망", "예수", "하나님", "천국", "기도", "말씀"];
            while (distractors.size < 2) {
                const genericWord = genericDistractors[Math.floor(Math.random() * genericDistractors.length)];
                if (genericWord !== correctWord && !distractors.has(genericWord)) {
                    distractors.add(genericWord);
                }
            }
            
            return Array.from(distractors);
        }

        // --- Event Listeners ---
        gameplayModeSelector.addEventListener('click', async (e) => {
            if (e.target.tagName !== 'BUTTON') return;
            gameplayMode = e.target.dataset.gameplay;
            gameplayModeSelector.querySelectorAll('.gameplay-btn').forEach(btn => btn.classList.remove('selected'));
            e.target.classList.add('selected');

            fillInBlankSettings.classList.toggle('hidden', gameplayMode !== 'fill-in-blank');
            moleWhackSettings.classList.toggle('hidden', gameplayMode !== 'mole-whack');
            
            if (gameId) {
                 await updateDoc(doc(db, "games", gameId), { "settings.gameplayMode": gameplayMode });
            }
        });

        gameModeSelector.addEventListener('click', async (e) => {
            if (e.target.tagName !== 'BUTTON') return;
            gameMode = e.target.dataset.mode;
            gameModeSelector.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('selected'));
            e.target.classList.add('selected');
            if (gameId) await updateDoc(doc(db, "games", gameId), { mode: gameMode });
            teamSettingsContainer.classList.toggle('hidden', gameMode !== 'team');
            playerListContainer.classList.toggle('hidden', gameMode === 'team');
            teamDisplay.classList.toggle('hidden', gameMode !== 'team');
            teamDisplay.classList.toggle('grid', gameMode === 'team');
            updatePlayerListUI();
        });
        
        teamThemeSelector.addEventListener('click', async (e) => {
            if (e.target.tagName !== 'BUTTON') return;
            teamTheme = e.target.dataset.theme;
            teamThemeSelector.querySelectorAll('.theme-btn').forEach(btn => btn.classList.remove('selected'));
            e.target.classList.add('selected');
            const nameTheme = teamNameThemes[teamTheme];
            const teamAIndex = Math.floor(Math.random() * nameTheme.length);
            let teamBIndex;
            do { teamBIndex = Math.floor(Math.random() * nameTheme.length); } while (teamAIndex === teamBIndex);
            teams.teamA.name = nameTheme[teamAIndex];
            teams.teamB.name = nameTheme[teamBIndex];
            teamANameEl.textContent = teams.teamA.name;
            teamBNameEl.textContent = teams.teamB.name;
            if (gameId) await updateDoc(doc(db, "games", gameId), { teams: teams });
        });

        teamAssignSelector.addEventListener('click', async (e) => {
            if (e.target.tagName !== 'BUTTON') return;
            assignMode = e.target.dataset.assign;
            teamAssignSelector.querySelectorAll('.assign-btn').forEach(btn => btn.classList.remove('selected'));
            e.target.classList.add('selected');
            if (gameId) await updateDoc(doc(db, "games", gameId), { assignMode: assignMode });
        });

        reshuffleBtn.addEventListener('click', async () => {
            const batch = writeBatch(db);
            const playerIds = Object.keys(players);
            playerIds.sort(() => Math.random() - 0.5); 
            playerIds.forEach((id, index) => {
                const team = index % 2 === 0 ? 'teamA' : 'teamB';
                const playerRef = doc(db, "games", gameId, "players", id);
                batch.update(playerRef, { team: team });
            });
            await batch.commit();
        });

        pauseGameBtn.addEventListener('click', () => {
            isGamePaused = !isGamePaused;
            pauseGameBtn.textContent = isGamePaused ? '계속' : '일시정지';
            pauseGameBtn.classList.toggle('bg-yellow-500', !isGamePaused);
            pauseGameBtn.classList.toggle('bg-green-500', isGamePaused);
            if(gameId) updateDoc(doc(db,"games", gameId), { paused: isGamePaused });
        });
        
        forceEndGameBtn.addEventListener('click', endGame);
        startGameButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', () => window.location.reload());
        copyUrlButton.addEventListener('click', () => {
            pcJoinUrlInput.select();
            document.execCommand('copy');
            copyUrlButton.textContent = '복사됨!';
            setTimeout(() => { copyUrlButton.textContent = '복사'; }, 1500);
        });
        soundToggleBtn.addEventListener('click', toggleSound);

        async function loadDataAndInit() {
            try {
                const response = await fetch('verses.json');
                if (!response.ok) throw new Error('verses.json을 불러올 수 없습니다.');
                versesData = await response.json();
                const categories = ['전체', ...new Set(versesData.map(v => v.카테고리).filter(Boolean))];
                categorySelector.innerHTML = '';
                categories.forEach(cat => {
                    const btn = document.createElement('button');
                    btn.textContent = cat;
                    btn.dataset.category = cat;
                    btn.className = 'category-btn p-2 border rounded-md bg-white hover:bg-sky-200 transition';
                    if (cat === '전체') btn.classList.add('selected');
                    btn.addEventListener('click', () => {
                        btn.classList.toggle('selected');
                        const isAllSelected = categorySelector.querySelector('[data-category="전체"]').classList.contains('selected');
                        if (btn.dataset.category === '전체' && btn.classList.contains('selected')) {
                            categorySelector.querySelectorAll('.category-btn').forEach(b => {
                                if (b !== btn) b.classList.remove('selected');
                            });
                        } else if (btn.dataset.category !== '전체' && btn.classList.contains('selected')) {
                             if(isAllSelected) categorySelector.querySelector('[data-category="전체"]').classList.remove('selected');
                        }
                    });
                    categorySelector.appendChild(btn);
                });
                await initializeHost();
            } catch (error) {
                console.error("초기화 오류:", error);
                alert("게임을 초기화하는 데 실패했습니다. 페이지를 새로고침 해주세요.");
            }
        }

        loadDataAndInit();
    </script>
</body>
</html>